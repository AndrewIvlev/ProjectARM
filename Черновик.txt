using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace projarm
{
    public class MathModel
    {
        public delegate double delegates(ref double[] q);
        public static delegates[] dh1podqi = new delegates[]
                                         {
                                      new delegates(dh1podq1),
                                      new delegates(dh1podq2),
                                      new delegates(dh1podq3),
                                      new delegates(dh1podq4)
                                         };
        public static delegates[] dh2podqi = new delegates[]
                                         {
                                      new delegates(dh2podq1),
                                      new delegates(dh2podq2),
                                      new delegates(dh2podq3),
                                      new delegates(dh2podq4)
                                         };
        public static double[] len;
        public static double[] angle;
        public double[] dq;
        readonly int N;

        public MathModel(int _N)
        {
            N = _N;
            len = new double[N];
            angle = new double[N];
            dq = new double[N];
        }
        public MathModel(double[] _len, double[] _angle, double[] _dq)
        {
            len = new double[N];
            angle = new double[N];
            dq = new double[N];

            for (int i = 0; i < N; i++)
            {
                len[i] = _len[i];
                angle[i] = _angle[i];
                dq[i] = _dq[i];
            }
        }
        public double[] LagrangeMethod(ref double[] q, double[] xy)
        {
            double[,] A = new double[,] {
                { Math.Pow(dFxpodq1(ref q), 2) + Math.Pow(dFxpodq2(ref q), 2) + Math.Pow(dFxpodq3(ref q), 2) + Math.Pow(dFxpodq4(ref q), 2),
                dFxpodq1(ref q) * dFypodq1(ref q) + dFxpodq2(ref q) * dFypodq2(ref q) + dFxpodq3(ref q) * dFypodq3(ref q) + dFxpodq4(ref q) * dFypodq4(ref q) },
                { dFxpodq1(ref q) * dFypodq1(ref q) + dFxpodq2(ref q) * dFypodq2(ref q) + dFxpodq3(ref q) * dFypodq3(ref q) + dFxpodq4(ref q) * dFypodq4(ref q),
                Math.Pow(dFypodq1(ref q), 2) + Math.Pow(dFypodq2(ref q), 2) + Math.Pow(dFypodq3(ref q), 2) + Math.Pow(dFypodq4(ref q), 2) }
               };
            double[] b = new double[2] {xy[0] - Fx(q), xy[1] - Fy(q)};
            double[] ?? = CramerMethod(A, b);
            
            double[] error = SolutionVerification(A, b, ??);
            if (Math.Sqrt(error[0] * error[0] + error[1] * error[1]) > 4)
                ;

            for (int i = 0; i < 4; i++)
                dq[i] = MagicFunc(??, q, dh1podqi[i], dh2podqi[i]);
            return dq;
        }
        public double MagicFunc(double[] ??, double[] q, delegates dFxpoqi, delegates dFypodqi)
        {
            return (??[0] * dFxpoqi(ref q) + ??[1] * dFypodqi(ref q)) / 2;
        }
        public double[] CramerMethod(double[,] A, double[] b)
        {
            double[] x = new double[2] {0, 0};
            double det = A[0, 0] * A[1, 1] - A[0, 1] * A[1, 0];
            if (det != 0)
            {
                double detx1 = b[0] * A[1, 1] - A[0, 1] * b[1];
                x[0] = detx1 / det;
                double detx2 = A[0, 0] * b[1] - b[0] * A[1, 0];
                x[1] = detx2 / det;
            }
            return x;
        }
        public double[] SolutionVerification(double[,] A, double[] b, double[] x)
        {
            double[] error = new double[2];
            error[0] = b[0] - A[0, 0] * x[0] - A[0, 1] * x[1];
            error[1] = b[1] - A[1, 0] * x[0] - A[1, 1] * x[1];
            return error;
        }
        public double Fx(double[] q)
        {
            return len[0] * Math.Cos(q[0]) + (len[1] + len[2] + q[2]) * Math.Cos(q[0] + q[1]) + len[3] * Math.Cos(q[0] + q[1] + q[3]);
        }
        public double Fy(double[] q)
        {
            return len[0] * Math.Sin(q[0]) + (len[1] + len[2] + q[2]) * Math.Sin(q[0] + q[1]) + len[3] * Math.Sin(q[0] + q[1] + q[3]);
        }
        public double h1(double [] q)
        {
            return -len[0] * Math.Sin(q[0]) - 2 * (len[1] + len[2] + q[2]) * Math.Sin(q[0] + q[1]) - 3 * len[3] * Math.Sin(q[0] + q[1] + q[3]) + Math.Cos(q[0] + q[1]);
        }
        public double h2(double[] q)
        {
            return len[0] * Math.Cos(q[0]) + 2 * (len[1] + len[2] + q[2]) * Math.Cos(q[0] + q[1]) + 3 * len[3] * Math.Cos(q[0] + q[1] + q[3]) + Math.Sin(q[0] + q[1]);
        }
        public static double dh1podq1(ref double[] q)
        {
            return - len[0] * Math.Cos(q[0]) - 2 * (len[1] + len[2] + q[2]) * Math.Cos(q[0] + q[1]) - 3 * len[3] * Math.Cos(q[0] + q[1] + q[3]) - Math.Sin(q[0] + q[1]);
        }
        public static double dh1podq2(ref double[] q)
        {
            return - 2 * (len[1] + len[2] + q[2]) * Math.Cos(q[0] + q[1]) - 3 * len[3] * Math.Cos(q[0] + q[1] + q[3]) - Math.Sin(q[0] + q[1]);
        }
        public static double dh1podq3(ref double[] q)
        {
            return - 2 * Math.Sin(q[0] + q[1]);
        }
        public static double dh1podq4(ref double[] q)
        {
            return - 3 * len[3] * Math.Cos(q[0] + q[1] + q[3]);
        }
        public static double dh2podq1(ref double[] q)
        {
            return - len[0] * Math.Sin(q[0]) - 2 * (len[1] + len[2] + q[2]) * Math.Sin(q[0] + q[1]) - 3 * len[3] * Math.Sin(q[0] + q[1] + q[3]) + Math.Cos(q[0] + q[1]);
        }
        public static double dh2podq2(ref double[] q)
        {
            return - 2 * (len[1] + len[2] + q[2]) * Math.Sin(q[0] + q[1]) - 3 * len[3] * Math.Sin(q[0] + q[1] + q[3]) + Math.Cos(q[0] + q[1]);
        }
        public static double dh2podq3(ref double[] q)
        {
            return - 2 * Math.Sin(q[0] + q[1]);
        }
        public static double dh2podq4(ref double[] q)
        {
            return - 3 * len[3] * Math.Sin(q[0] + q[1] + q[3]);
        }
    }
}